<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claim Process Flow Tree</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.2em;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }

        select {
            padding: 10px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            min-width: 200px;
            transition: all 0.3s;
        }

        select:hover {
            border-color: #667eea;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .stats-bar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 30px;
            color: white;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
        }

        .stat-label {
            font-size: 1em;
            margin-top: 8px;
            opacity: 0.95;
        }

        #tree-container {
            width: 100%;
            overflow-x: auto;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            background: #fafbfc;
            min-height: 600px;
            position: relative;
        }

        .node circle {
            fill: #fff;
            stroke: #667eea;
            stroke-width: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .node circle:hover {
            stroke: #764ba2;
            stroke-width: 4px;
            filter: drop-shadow(0 0 8px rgba(102, 126, 234, 0.6));
        }

        .node.has-children circle {
            fill: #e3f2fd;
        }

        .node.expanded circle {
            fill: #bbdefb;
        }

        .node.termination circle {
            fill: #f44336;
            stroke: #d32f2f;
            cursor: default;
        }

        .node.root circle {
            display: none;
        }

        .node text {
            font-size: 12px;
            font-weight: 600;
            fill: #2c3e50;
        }

        .node .count-text {
            font-size: 11px;
            fill: #666;
        }

        .node .percentage-text {
            font-size: 11px;
            font-weight: bold;
            fill: #667eea;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }

        .link.active {
            stroke: #667eea;
            stroke-width: 3px;
        }

        .tooltip {
            position: absolute;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 8px;
            pointer-events: none;
            font-size: 13px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            max-width: 300px;
        }

        .tooltip .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ffd700;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #667eea;
            font-size: 1.2em;
        }

        .spinner {
            border: 4px solid rgba(102, 126, 234, 0.3);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #555;
        }

        .legend-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid;
        }

        .legend-circle.process {
            background: white;
            border-color: #667eea;
        }

        .legend-circle.termination {
            background: #f44336;
            border-color: #d32f2f;
        }

        .legend-circle.expandable {
            background: #e3f2fd;
            border-color: #667eea;
        }

        .info-text {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-top: 15px;
            font-style: italic;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ðŸŒ³ Claim Process Flow Tree</h1>

        <div id="stats" class="stats-bar" style="display: none;">
            <!-- Stats will be populated dynamically -->
        </div>

        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>Loading process data...</p>
        </div>

        <div id="tree-container" style="display: none;">
            <svg id="tree-svg"></svg>
        </div>

        <div class="legend" id="legend" style="display: none;">
            <div class="legend-item">
                <div class="legend-circle process"></div>
                <span>Process Node</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle termination"></div>
                <span>Termination (End of Process)</span>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        const API_BASE = 'http://localhost:8000/api';
        let treeData = null;
        let allStartingProcesses = [];

        // Fetch API wrapper
        async function fetchAPI(endpoint) {
            try {
                const response = await fetch(`${API_BASE}${endpoint}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('API Error:', error);
                throw error;
            }
        }

        // Load all starting processes and display them as root nodes
        async function loadAllStartingProcesses() {
            showLoading();

            try {
                const data = await fetchAPI('/starting-processes');
                allStartingProcesses = data.starting_processes;

                // Create array of starting processes without a root node
                treeData = allStartingProcesses.map(sp => ({
                    name: sp.process,
                    count: sp.count,
                    percentage: sp.percentage,
                    path: [],
                    children: [],
                    hasChildren: true,
                    isStarting: true
                }));

                // Update stats
                updateStats(data);

                // Draw tree
                drawTree(treeData);

                hideLoading();
            } catch (error) {
                console.error('Error loading starting processes:', error);
                alert('Failed to load starting processes. Make sure the FastAPI server is running on port 8000.');
            }
        }

        // Build tree data structure recursively
        async function buildTreeData(processName, filterType = 'starting', path = [], depth = 0, maxDepth = 1) {
            // Only build immediate children (1 level deep initially)
            if (depth >= maxDepth) {
                return null;
            }

            try {
                let data;
                if (path.length === 0) {
                    // First level - use the starting process API
                    data = await fetchAPI(`/process-flow/${encodeURIComponent(processName)}?filter_type=${filterType}`);
                } else {
                    // Subsequent levels - use the path-based API
                    const pathStr = path.join(',');
                    data = await fetchAPI(`/process-flow-after-path?path=${encodeURIComponent(pathStr)}`);
                }

                const node = {
                    name: processName,
                    count: data.total_claims,
                    totalFlows: data.total_flows,
                    path: [...path],
                    children: [],
                    _children: null // Hidden children (for expansion)
                };

                // Add termination as a child if exists
                if (data.terminations.count > 0) {
                    node.children.push({
                        name: 'ðŸ Terminated',
                        count: data.terminations.count,
                        percentage: data.terminations.percentage,
                        isTermination: true,
                        path: [...path, processName]
                    });
                }

                // Add next steps as children (collapsed by default)
                for (const step of data.next_steps) {
                    const childNode = {
                        name: step.process,
                        count: step.count,
                        percentage: step.percentage,
                        path: [...path, processName],
                        children: [], // Empty initially - will load on click
                        hasChildren: true // Flag to show it can be expanded
                    };
                    node.children.push(childNode);
                }

                return node;
            } catch (error) {
                console.error(`Error fetching data for ${processName}:`, error);
                return null;
            }
        }

        // Expand a node by loading its children
        async function expandNode(nodeData) {
            if (nodeData.isTermination || nodeData.isRoot) {
                return; // Cannot expand termination or root nodes
            }

            // Build path for this node
            const fullPath = nodeData.isStarting ? [nodeData.name] : [...nodeData.path, nodeData.name];

            console.log('=== Expanding Node ===');
            console.log('Node name:', nodeData.name);
            console.log('Node count:', nodeData.count);
            console.log('Full path:', fullPath.join(' â†’ '));
            console.log('Is starting:', nodeData.isStarting);

            try {
                // Fetch children using appropriate API
                let data;
                if (nodeData.isStarting) {
                    // For starting nodes, use the starting filter
                    const url = `/process-flow/${encodeURIComponent(nodeData.name)}?filter_type=starting`;
                    console.log('API call:', url);
                    data = await fetchAPI(url);
                } else {
                    // For subsequent nodes, use path-based API
                    const pathStr = fullPath.join(',');
                    const url = `/process-flow-after-path?path=${encodeURIComponent(pathStr)}`;
                    console.log('API call:', url);
                    data = await fetchAPI(url);
                }

                console.log('API response:', data);

                // Clear existing children and add new ones
                nodeData.children = [];

                // Add termination
                if (data.terminations.count > 0) {
                    nodeData.children.push({
                        name: 'ðŸ Terminated',
                        count: data.terminations.count,
                        percentage: data.terminations.percentage,
                        isTermination: true,
                        path: fullPath
                    });
                }

                // Add next steps
                for (const step of data.next_steps) {
                    nodeData.children.push({
                        name: step.process,
                        count: step.count,  // This is the actual flow count from this parent
                        percentage: step.percentage,
                        path: fullPath,
                        children: [],
                        hasChildren: true,
                        parentCount: nodeData.count  // Store parent count for validation
                    });
                }

                nodeData.expanded = true;

                // Validation: check if child counts sum correctly
                const totalChildCount = nodeData.children.reduce((sum, child) => sum + child.count, 0);
                console.log(`Expanded ${nodeData.name}: parent count=${nodeData.count}, children sum=${totalChildCount}`);
                if (totalChildCount !== nodeData.count && !nodeData.isStarting) {
                    console.warn(`Warning: Children counts don't match parent! Path: ${fullPath.join(' â†’ ')}`);
                }

                // Redraw tree with updated data
                drawTree(treeData);
            } catch (error) {
                console.error('Error expanding node:', error);
                alert('Failed to load child nodes');
            }
        }

        // Collapse a node
        function collapseNode(nodeData) {
            nodeData.children = [];
            nodeData.expanded = false;

            // Redraw entire tree
            drawTree(treeData);
        }

        // Draw tree using D3
        function drawTree(data) {
            const container = document.getElementById('tree-container');
            container.style.display = 'block';
            document.getElementById('legend').style.display = 'flex';

            // Clear existing SVG
            d3.select('#tree-svg').selectAll('*').remove();

            // Calculate required dimensions based on data
            let maxDepth = 1;
            let maxChildren = 1;

            if (Array.isArray(data)) {
                data.forEach(rootData => {
                    const root = d3.hierarchy(rootData);
                    let depth = 0;
                    root.each(d => {
                        depth = Math.max(depth, d.depth);
                        if (d.children) {
                            maxChildren = Math.max(maxChildren, d.children.length);
                        }
                    });
                    maxDepth = Math.max(maxDepth, depth);
                });
            }

            // Set dimensions dynamically
            const width = Math.max(1800, container.clientWidth, data.length * 180);
            const height = Math.max(600, (maxDepth + 1) * 200 + 100);

            const svg = d3.select('#tree-svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', 'translate(0, 20)');

            // If data is an array (multiple roots), handle differently
            if (Array.isArray(data)) {
                drawMultipleRoots(g, data, width, height);
            } else {
                drawSingleTree(g, data, width, height);
            }
        }

        // Draw multiple root nodes (starting processes) using force simulation
        function drawMultipleRoots(g, dataArray, width, height) {
            // Flatten all nodes from all trees into a single array
            const allNodes = [];
            const allLinks = [];

            dataArray.forEach((rootData, treeIndex) => {
                const root = d3.hierarchy(rootData);

                // Add all nodes
                root.each(d => {
                    allNodes.push({
                        id: `${treeIndex}-${d.data.name}-${d.depth}`,
                        data: d.data,
                        depth: d.depth,
                        treeIndex: treeIndex,
                        parent: d.parent ? `${treeIndex}-${d.parent.data.name}-${d.parent.depth}` : null
                    });
                });

                // Add all links
                root.links().forEach(link => {
                    allLinks.push({
                        source: `${treeIndex}-${link.source.data.name}-${link.source.depth}`,
                        target: `${treeIndex}-${link.target.data.name}-${link.target.depth}`
                    });
                });
            });

            // Calculate node radius based on count and depth
            const getRadius = (d) => {
                const nodesAtDepth = allNodes.filter(n => n.depth === d.depth);
                const counts = nodesAtDepth.map(n => n.data.count || 1);
                const minCount = Math.min(...counts);
                const maxCount = Math.max(...counts);

                const maxRadius = Math.max(30, 45 - (d.depth * 3));
                const minRadius = Math.max(18, 25 - (d.depth * 2));

                const scale = d3.scaleSqrt()
                    .domain([minCount, maxCount])
                    .range([minRadius, maxRadius]);

                return scale(d.data.count || 1);
            };

            // Add radius to nodes
            allNodes.forEach(d => {
                d.radius = getRadius(d);
            });

            // Create force simulation
            const simulation = d3.forceSimulation(allNodes)
                .force('link', d3.forceLink(allLinks)
                    .id(d => d.id)
                    .distance(d => {
                        // Distance based on depth
                        const sourceNode = allNodes.find(n => n.id === d.source.id);
                        return 120 + (sourceNode.depth * 20);
                    })
                    .strength(0.5))
                .force('charge', d3.forceManyBody()
                    .strength(d => -300 - (d.radius * 5)))
                .force('collision', d3.forceCollide()
                    .radius(d => d.radius + 15)
                    .strength(0.9))
                .force('x', d3.forceX(d => {
                    // Spread trees horizontally
                    const treeSpacing = width / (dataArray.length + 1);
                    return treeSpacing * (d.treeIndex + 1);
                }).strength(0.3))
                .force('y', d3.forceY(d => {
                    // Arrange by depth vertically
                    return 100 + (d.depth * 180);
                }).strength(0.5))
                .alphaDecay(0.02)
                .velocityDecay(0.3);

            // Draw links
            const links = g.selectAll('.link')
                .data(allLinks)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 2);

            // Draw nodes
            const nodes = g.selectAll('.node')
                .data(allNodes)
                .enter()
                .append('g')
                .attr('class', d => {
                    let classes = 'node';
                    if (d.data.isTermination) classes += ' termination';
                    if (d.data.hasChildren && !d.data.expanded) classes += ' has-children';
                    if (d.data.expanded) classes += ' expanded';
                    return classes;
                })
                .on('mouseover', (event, d) => showTooltip(event, { data: d.data }))
                .on('mouseout', hideTooltip)
                .on('click', async function (event, d) {
                    event.stopPropagation();
                    if (d.data.isTermination) return;

                    if (d.data.expanded) {
                        collapseNode(d.data);
                    } else if (d.data.hasChildren) {
                        await expandNode(d.data);
                    }
                });

            // Add circles
            nodes.append('circle')
                .attr('r', d => d.radius);

            // Add process name
            nodes.append('text')
                .attr('dy', d => -d.radius - 8)
                .attr('text-anchor', 'middle')
                .style('font-size', '11px')
                .style('font-weight', '600')
                .each(function (d) {
                    const text = d3.select(this);
                    const words = d.data.name.split(' ');

                    if (words.length > 2) {
                        text.append('tspan')
                            .attr('x', 0)
                            .attr('dy', 0)
                            .text(words.slice(0, 2).join(' '));
                        text.append('tspan')
                            .attr('x', 0)
                            .attr('dy', 11)
                            .text(words.slice(2).join(' '));
                    } else {
                        text.text(d.data.name);
                    }
                });

            // Add count
            nodes.append('text')
                .attr('class', 'count-text')
                .attr('dy', -2)
                .attr('text-anchor', 'middle')
                .style('font-weight', 'bold')
                .style('font-size', d => Math.max(10, d.radius / 2.5) + 'px')
                .text(d => d.data.count);

            // Add percentage
            nodes.append('text')
                .attr('class', 'percentage-text')
                .attr('dy', 9)
                .attr('text-anchor', 'middle')
                .style('font-size', d => Math.max(9, d.radius / 3.2) + 'px')
                .text(d => d.data.percentage ? `${d.data.percentage}%` : '');

            // Update positions on each tick
            simulation.on('tick', () => {
                links
                    .attr('x1', d => {
                        const source = allNodes.find(n => n.id === d.source.id);
                        return source ? source.x : 0;
                    })
                    .attr('y1', d => {
                        const source = allNodes.find(n => n.id === d.source.id);
                        return source ? source.y : 0;
                    })
                    .attr('x2', d => {
                        const target = allNodes.find(n => n.id === d.target.id);
                        return target ? target.x : 0;
                    })
                    .attr('y2', d => {
                        const target = allNodes.find(n => n.id === d.target.id);
                        return target ? target.y : 0;
                    });

                nodes.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Stop simulation after a while to save resources
            setTimeout(() => simulation.stop(), 5000);
        }

        // Draw single tree (when not at root level)
        function drawSingleTree(g, data, width, height) {
            // This would be used if we ever switch to single tree view
            // For now, just use the multiple roots approach
        }

        // Tooltip functions
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';

            let html = `<div class="tooltip-title">${d.data.name}</div>`;
            html += `<div>Claims: ${d.data.count}</div>`;
            if (d.data.percentage) {
                html += `<div>Percentage: ${d.data.percentage}%</div>`;
            }
            if (d.data.totalFlows) {
                html += `<div>Total Flows: ${d.data.totalFlows}</div>`;
            }

            tooltip.innerHTML = html;
            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY + 15) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        // Update stats bar
        function updateStats(data) {
            const statsDiv = document.getElementById('stats');
            statsDiv.style.display = 'flex';

            let totalClaims = data.total_claims || 0;
            let totalProcesses = data.starting_processes ? data.starting_processes.length : 0;

            statsDiv.innerHTML = `
                <div class="stat-item">
                    <div class="stat-value">${totalClaims}</div>
                    <div class="stat-label">Total Claims</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${totalProcesses}</div>
                    <div class="stat-label">Starting Processes</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">Click to Expand</div>
                    <div class="stat-label">Interactive Tree</div>
                </div>
            `;
        }

        function countNodes(node) {
            if (!node) return 0;
            let count = 1;
            if (node.children) {
                node.children.forEach(child => {
                    count += countNodes(child);
                });
            }
            return count;
        }

        function countTerminations(node) {
            if (!node) return 0;
            let count = node.isTermination ? 1 : 0;
            if (node.children) {
                node.children.forEach(child => {
                    count += countTerminations(child);
                });
            }
            return count;
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('tree-container').style.display = 'none';
            document.getElementById('stats').style.display = 'none';
            document.getElementById('legend').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // Initialize - Load all starting processes
        window.onload = loadAllStartingProcesses;
    </script>
</body>

</html>